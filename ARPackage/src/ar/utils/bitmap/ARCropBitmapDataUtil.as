/** * AnotherRainbow * @author Zzanzza */package ar.utils.bitmap {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;
		public class ARCropBitmapDataUtil 	{		public function ARCropBitmapDataUtil() 		{					}				public static function cropSquare($sourceBitmap:BitmapData):BitmapData		{			var ww:uint = $sourceBitmap.width;			var hh:uint = $sourceBitmap.height;						var len:uint = Math.min(ww, hh);						var btmData:BitmapData = new BitmapData(len, len);			var xx:uint = (ww - len) * .5;			var yy:uint = (hh - len) * .5;			btmData.copyPixels( $sourceBitmap, new Rectangle(xx, yy, len, len), new Point(0, 0));						$sourceBitmap.dispose();			return btmData;		}				public static function cropLimitOfLength($sourceImageData:BitmapData, $imageWidth:Number, $imageHeight:Number, $smooth:Boolean = true, cropAlign:String = "center"):BitmapData		{			var sBitmpData:BitmapData = $sourceImageData;			var sbw:Number = sBitmpData.width;			var sbh:Number = sBitmpData.height;						var rate:Number = Math.max($imageWidth / sbw, $imageHeight / sbh);			var sw:Number = sbw * rate;			var sh:Number = sbh * rate;						var gapW:int = Math.round((sw - $imageWidth) * .5);			var gapH:int = Math.round((sh - $imageHeight) * .5);						if (cropAlign == "top")			{				gapW = gapH = 0;			}			else if (cropAlign == "bottom")			{				gapW = Math.round(sw - $imageWidth);				gapH = Math.round(sh - $imageHeight);			}						var canvasBitmapData:BitmapData = new BitmapData($imageWidth, $imageHeight, true, 0);			var matrix:Matrix = new Matrix();			matrix.scale(rate, rate);			matrix.tx = -gapW;			matrix.ty = -gapH;			canvasBitmapData.draw(sBitmpData, matrix, null, null, null, $smooth);			sBitmpData.dispose();						return canvasBitmapData;		}				public static function cropPixelByRate($sourceBD:BitmapData, $rateX:Number, $rateY:Number, $rateW:Number, $rateH:Number, $pointX:Number = 0, $pointY:Number = 0):BitmapData		{			var bd   :BitmapData = new BitmapData($sourceBD.width*$rateW, $sourceBD.height*$rateH);			var rect :Rectangle  = new Rectangle ($sourceBD.width*$rateX, $sourceBD.height*$rateY, $sourceBD.width*$rateW, $sourceBD.height*$rateH);			var p    :Point      = new Point($sourceBD.width*$pointX, $sourceBD.height*$pointY);						bd.copyPixels($sourceBD, rect, p);						return bd;		}		public static function cropOnContainer($sourceBD:BitmapData, $containerW:Number, $containerH:Number, $bitmapRateX:Number, $bitmapRateY:Number, $containerBG:BitmapData = null):BitmapData		{			var container :Sprite = new Sprite();			var bmp	   	  :Bitmap = new Bitmap($sourceBD);			var tempW	  :Number;			var tempH     :Number;						if($containerBG)	{	var bg:Bitmap = new Bitmap($containerBG);										bg.width  = $containerW;										bg.height = $containerH;										container.addChild(bg);										tempW = container.width;										tempH = container.height;   		   }			else				{		tempW = $containerW;										tempH = $containerH;				   }							container.addChild(bmp);			container.width  = $containerW;			container.height = $containerH;						if($bitmapRateX == 0) bmp.x = 0;			else			{ 				var bitX:Number = $bitmapRateX*container.width;				var bitW:Number = bmp.width/2;									 if(bitX > bitW)	bmp.x = bitX - bitW;				else if(bitX < bitW)	bmp.x = bitX;			}						if($bitmapRateY == 0) bmp.y = 0;						else			{				bmp.y = $bitmapRateY*container.height - bmp.height/2;	// valign center.  setting for innisfree's textBitmapData //				bmp.y = $bitmapRateY*container.height;			}						var newBD:BitmapData = new BitmapData(tempW, tempH, true, 0x000000);			newBD.draw(container, null, null, null, null, true);						while(container.numChildren) container.removeChildAt(0);			if($containerBG) $containerBG.dispose();			$sourceBD.dispose();			return newBD;		}		public static function cropUnderContainer($sourceBD:BitmapData, $containerW:Number, $containerH:Number, $bitmapRateX:Number, $bitmapRateY:Number, $containerBG:BitmapData, $blendModeBG:String="normal"):BitmapData		{			var container :Sprite = new Sprite();			var bmp	   	  :Bitmap = new Bitmap($sourceBD);			var bg		  :Bitmap = new Bitmap($containerBG);						bg.width  = $containerW;			bg.height = $containerH;			bg.blendMode = $blendModeBG;			container.addChild(bmp);			container.addChild(bg);			container.width  = $containerW;			container.height = $containerH;						if($bitmapRateX == 0) bmp.x = 0;			else			{ 				var bitX:Number = $bitmapRateX*container.width;				var bitW:Number = bmp.width/2;				if(bitX > bitW)	bmp.x = bitX - bitW;				else if(bitX < bitW)	bmp.x = bitX;			}						if($bitmapRateY == 0) bmp.y = 0;						else				  bmp.y = $bitmapRateY*container.height - bmp.height/2;						var newBD:BitmapData = new BitmapData($containerW, $containerH, true, 0x000000);			newBD.draw(container, null, null, null, null, true);						while(container.numChildren) container.removeChildAt(0);			if($containerBG) $containerBG.dispose();			$sourceBD.dispose();			return newBD;		}				public static const SIZE_FIT_CONTAIN	:String = "SIZE_FIT_CONTAIN";		public static const SIZE_FIT_COVER		:String = "SIZE_FIT_COVER";		public static function resizeBitmapData($sourceBD:BitmapData, $width:uint, $height:uint, $size_fit:String="cover", $transparent:Boolean = false, $smooth:Boolean = false):BitmapData		{			var resultBD:BitmapData = new BitmapData($width, $height, $transparent, 0);			var scale:Number;			var newRect:Rectangle = new Rectangle(); 			if ($size_fit == SIZE_FIT_CONTAIN)			{				scale = Math.min($width/$sourceBD.width, $height/$sourceBD.height);			}			else			{				scale = Math.max($width/$sourceBD.width, $height/$sourceBD.height);			}						newRect.width = Math.ceil(scale*$sourceBD.width);			newRect.height = Math.ceil(scale*$sourceBD.height);			newRect.x = Math.round(($width-newRect.width)*0.5);			newRect.y = Math.round(($height-newRect.height)*0.5);						trace("resizeBitmapData", scale, newRect);						var m:Matrix =  new Matrix();			m.scale(scale, scale);			m.tx = newRect.x;			m.ty = newRect.y;			resultBD.draw($sourceBD, m, null, null, null, $smooth);						return resultBD;		}											}}